{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { formatSEODate, getSecondsSinceEpoch } from \"./formatters\";\nimport { config } from \"../config/config.yml\"; // _app.js and _document.js are next.js specific files, and should be ignored\n// the blog directory is ignored here, but is processed in post-list.js\n\nconst ignoreList = [\"_app.js\", \"_document.js\", \"blog\"];\n\nconst pageFileNames = () => {\n  const allPageFileNames = [\"_app.js\", \"_document.js\", \"about.js\", \"blog\", \"blog.js\", \"index.mdx\", \"search.js\"] || [];\n  const filteredFileNames = allPageFileNames.filter(name => !name || !ignoreList.includes(name));\n  return Promise.resolve(filteredFileNames);\n};\n\nconst createPageList = fileNameList => {\n  return fileNameList.reduce((collection, name) => {\n    // These are properties we want to extract from the file's meta export.\n    // This data is returned is added to the `collection` array below.\n    const {\n      default: Component\n    } = require(`../pages/${name}`);\n\n    const _require$meta = require(`../pages/${name}`).meta,\n          {\n      title,\n      tags,\n      layout,\n      publishDate,\n      modifiedDate,\n      seoDescription,\n      hideProgressBar = false // any extra properties a page may have\n\n    } = _require$meta,\n          moreMeta = _objectWithoutProperties(_require$meta, [\"title\", \"tags\", \"layout\", \"publishDate\", \"modifiedDate\", \"seoDescription\", \"hideProgressBar\"]); // remove the extension from the file name to make a component name string\n\n\n    let cleaned_name = name.split(\".\")[0]; // format dates for SEO, but preserve publishDate as the latter is\n    // displayed on the blog post. Currently not displaying modifiedDate, but\n    // preserving it for possible future use.\n\n    const formattedPublishDate = formatSEODate(publishDate);\n    const formattedModifiedDate = formatSEODate(modifiedDate, true); // This is used to sort pages/posts\n\n    const secondsSinceEpoch = getSecondsSinceEpoch(formattedPublishDate); // data that is returned for each page\n\n    collection.push(_objectSpread({\n      Component,\n      title,\n      tags,\n      layout,\n      publishDate,\n      formattedPublishDate,\n      modifiedDate,\n      formattedModifiedDate,\n      seoDescription,\n      urlPath: `/${cleaned_name === \"index\" ? \"\" : cleaned_name}`,\n      canonicalUrl: `${config.baseUrl}/${cleaned_name === \"index\" ? \"\" : cleaned_name}`,\n      hideProgressBar,\n      name: cleaned_name,\n      type: \"page\",\n      secondsSinceEpoch\n    }, moreMeta));\n    return collection;\n  }, []);\n};\n\nexport function pages() {\n  return pageFileNames().then(fileNameList => {\n    const pageList = createPageList(fileNameList);\n    const sortedList = pageList.sort((a, b) => a.secondsSinceEpoch - b.secondsSinceEpoch).reverse();\n    return sortedList;\n  }).catch(error => console.log(\"Error creating pageList\", error));\n}","map":{"version":3,"sources":["/home/wajari/dev/blog-next/utils/page-list.js"],"names":["formatSEODate","getSecondsSinceEpoch","config","ignoreList","pageFileNames","allPageFileNames","filteredFileNames","filter","name","includes","Promise","resolve","createPageList","fileNameList","reduce","collection","default","Component","require","meta","title","tags","layout","publishDate","modifiedDate","seoDescription","hideProgressBar","moreMeta","cleaned_name","split","formattedPublishDate","formattedModifiedDate","secondsSinceEpoch","push","urlPath","canonicalUrl","baseUrl","type","pages","then","pageList","sortedList","sort","a","b","reverse","catch","error","console","log"],"mappings":";;;;;;;;;;AAAA,SAASA,aAAT,EAAwBC,oBAAxB,QAAoD,cAApD;AACA,SAASC,MAAT,QAAuB,sBAAvB,C,CAEA;AACA;;AACA,MAAMC,UAAU,GAAG,CAAC,SAAD,EAAY,cAAZ,EAA4B,MAA5B,CAAnB;;AAEA,MAAMC,aAAa,GAAG,MAAM;AACxB,QAAMC,gBAAgB,GAClB,wFAAiE,EADrE;AAEA,QAAMC,iBAAiB,GAAGD,gBAAgB,CAACE,MAAjB,CACtBC,IAAI,IAAI,CAACA,IAAD,IAAS,CAACL,UAAU,CAACM,QAAX,CAAoBD,IAApB,CADI,CAA1B;AAGA,SAAOE,OAAO,CAACC,OAAR,CAAgBL,iBAAhB,CAAP;AACH,CAPD;;AASA,MAAMM,cAAc,GAAGC,YAAY,IAAI;AACnC,SAAOA,YAAY,CAACC,MAAb,CAAoB,CAACC,UAAD,EAAaP,IAAb,KAAsB;AAC7C;AACA;AACA,UAAM;AAAEQ,MAAAA,OAAO,EAAEC;AAAX,QAAyBC,OAAO,CAAE,YAAWV,IAAK,EAAlB,CAAtC;;AACA,0BASIU,OAAO,CAAE,YAAWV,IAAK,EAAlB,CAAP,CAA4BW,IAThC;AAAA,UAAM;AACFC,MAAAA,KADE;AAEFC,MAAAA,IAFE;AAGFC,MAAAA,MAHE;AAIFC,MAAAA,WAJE;AAKFC,MAAAA,YALE;AAMFC,MAAAA,cANE;AAOFC,MAAAA,eAAe,GAAG,KAPhB,CAQU;;AARV,KAAN;AAAA,UAQOC,QARP,4IAJ6C,CAe7C;;;AACA,QAAIC,YAAY,GAAGpB,IAAI,CAACqB,KAAL,CAAW,GAAX,EAAgB,CAAhB,CAAnB,CAhB6C,CAkB7C;AACA;AACA;;AACA,UAAMC,oBAAoB,GAAG9B,aAAa,CAACuB,WAAD,CAA1C;AAEA,UAAMQ,qBAAqB,GAAG/B,aAAa,CAACwB,YAAD,EAAe,IAAf,CAA3C,CAvB6C,CAyB7C;;AACA,UAAMQ,iBAAiB,GAAG/B,oBAAoB,CAAC6B,oBAAD,CAA9C,CA1B6C,CA4B7C;;AACAf,IAAAA,UAAU,CAACkB,IAAX;AACIhB,MAAAA,SADJ;AAEIG,MAAAA,KAFJ;AAGIC,MAAAA,IAHJ;AAIIC,MAAAA,MAJJ;AAKIC,MAAAA,WALJ;AAMIO,MAAAA,oBANJ;AAOIN,MAAAA,YAPJ;AAQIO,MAAAA,qBARJ;AASIN,MAAAA,cATJ;AAUIS,MAAAA,OAAO,EAAG,IAAGN,YAAY,KAAK,OAAjB,GAA2B,EAA3B,GAAgCA,YAAa,EAV9D;AAWIO,MAAAA,YAAY,EAAG,GAAEjC,MAAM,CAACkC,OAAQ,IAC5BR,YAAY,KAAK,OAAjB,GAA2B,EAA3B,GAAgCA,YACnC,EAbL;AAcIF,MAAAA,eAdJ;AAeIlB,MAAAA,IAAI,EAAEoB,YAfV;AAgBIS,MAAAA,IAAI,EAAE,MAhBV;AAiBIL,MAAAA;AAjBJ,OAkBOL,QAlBP;AAqBA,WAAOZ,UAAP;AACH,GAnDM,EAmDJ,EAnDI,CAAP;AAoDH,CArDD;;AAuDA,OAAO,SAASuB,KAAT,GAAiB;AACpB,SAAOlC,aAAa,GACfmC,IADE,CACG1B,YAAY,IAAI;AAClB,UAAM2B,QAAQ,GAAG5B,cAAc,CAACC,YAAD,CAA/B;AACA,UAAM4B,UAAU,GAAGD,QAAQ,CACtBE,IADc,CACT,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACX,iBAAF,GAAsBY,CAAC,CAACZ,iBADzB,EAEda,OAFc,EAAnB;AAGA,WAAOJ,UAAP;AACH,GAPE,EAQFK,KARE,CAQIC,KAAK,IAAIC,OAAO,CAACC,GAAR,CAAY,yBAAZ,EAAuCF,KAAvC,CARb,CAAP;AASH","sourcesContent":["import { formatSEODate, getSecondsSinceEpoch } from \"./formatters\";\nimport { config } from \"../config/config.yml\";\n\n// _app.js and _document.js are next.js specific files, and should be ignored\n// the blog directory is ignored here, but is processed in post-list.js\nconst ignoreList = [\"_app.js\", \"_document.js\", \"blog\"];\n\nconst pageFileNames = () => {\n    const allPageFileNames =\n        preval`module.exports = require(\"fs\").readdirSync(\"./pages\")` || [];\n    const filteredFileNames = allPageFileNames.filter(\n        name => !name || !ignoreList.includes(name)\n    );\n    return Promise.resolve(filteredFileNames);\n};\n\nconst createPageList = fileNameList => {\n    return fileNameList.reduce((collection, name) => {\n        // These are properties we want to extract from the file's meta export.\n        // This data is returned is added to the `collection` array below.\n        const { default: Component } = require(`../pages/${name}`);\n        const {\n            title,\n            tags,\n            layout,\n            publishDate,\n            modifiedDate,\n            seoDescription,\n            hideProgressBar = false,\n            ...moreMeta // any extra properties a page may have\n        } = require(`../pages/${name}`).meta;\n\n        // remove the extension from the file name to make a component name string\n        let cleaned_name = name.split(\".\")[0];\n\n        // format dates for SEO, but preserve publishDate as the latter is\n        // displayed on the blog post. Currently not displaying modifiedDate, but\n        // preserving it for possible future use.\n        const formattedPublishDate = formatSEODate(publishDate);\n\n        const formattedModifiedDate = formatSEODate(modifiedDate, true);\n\n        // This is used to sort pages/posts\n        const secondsSinceEpoch = getSecondsSinceEpoch(formattedPublishDate);\n\n        // data that is returned for each page\n        collection.push({\n            Component,\n            title,\n            tags,\n            layout,\n            publishDate,\n            formattedPublishDate,\n            modifiedDate,\n            formattedModifiedDate,\n            seoDescription,\n            urlPath: `/${cleaned_name === \"index\" ? \"\" : cleaned_name}`,\n            canonicalUrl: `${config.baseUrl}/${\n                cleaned_name === \"index\" ? \"\" : cleaned_name\n            }`,\n            hideProgressBar,\n            name: cleaned_name,\n            type: \"page\",\n            secondsSinceEpoch,\n            ...moreMeta // any extra properties a page may have\n        });\n\n        return collection;\n    }, []);\n};\n\nexport function pages() {\n    return pageFileNames()\n        .then(fileNameList => {\n            const pageList = createPageList(fileNameList);\n            const sortedList = pageList\n                .sort((a, b) => a.secondsSinceEpoch - b.secondsSinceEpoch)\n                .reverse();\n            return sortedList;\n        })\n        .catch(error => console.log(\"Error creating pageList\", error));\n}\n"]},"metadata":{},"sourceType":"module"}
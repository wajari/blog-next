{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { formatSEODate, getSecondsSinceEpoch } from \"./formatters\";\nimport { config } from \"../config/config.yml\";\n\nconst postFileNames = () => {\n  const postFileNames = [\"blog-react.mdx\", \"post-four-link-on-twitter.mdx\", \"post-one-code-block-demo.mdx\", \"post-three-smooth-scroll-and-reading-progress-bar.mdx\", \"post-two-image-demo.mdx\"] || [];\n  return Promise.resolve(postFileNames);\n};\n\nconst createPostList = fileNameList => {\n  return fileNameList.reduce((collection, name) => {\n    // These are properties we want to extract from the file's meta export.\n    // This data is returned is added to the `collection` array below.\n    const {\n      default: Component\n    } = require(`../pages/blog/${name}`);\n\n    const _require$meta = require(`../pages/blog/${name}`).meta,\n          {\n      title,\n      tags,\n      layout,\n      publishDate,\n      modifiedDate,\n      seoDescription,\n      hideProgressBar = false,\n      exclude = false // any extra properties a post may have\n\n    } = _require$meta,\n          moreMeta = _objectWithoutProperties(_require$meta, [\"title\", \"tags\", \"layout\", \"publishDate\", \"modifiedDate\", \"seoDescription\", \"hideProgressBar\", \"exclude\"]);\n\n    if (exclude) return collection; // remove the extension from the file name to make a component name string\n\n    const cleaned_name = name.split(\".\")[0]; // format dates for SEO, but preserve publishDate as the latter is\n    // displayed on the blog post. Currently not displaying modifiedDate, but\n    // preserving it for possible future use.\n\n    const formattedPublishDate = formatSEODate(publishDate);\n    const formattedModifiedDate = formatSEODate(modifiedDate, true); // This is used to sort pages/posts\n\n    const secondsSinceEpoch = getSecondsSinceEpoch(formattedPublishDate); // data that is returned for each page\n\n    collection.push(_objectSpread({\n      Component,\n      title,\n      tags,\n      layout,\n      publishDate,\n      formattedPublishDate,\n      modifiedDate,\n      formattedModifiedDate,\n      seoDescription,\n      exclude,\n      urlPath: `/${cleaned_name}`,\n      fullUrlPath: `/blog/${cleaned_name}`,\n      canonicalUrl: `${config.baseUrl}/${cleaned_name}`,\n      hideProgressBar,\n      name: cleaned_name,\n      type: \"post\",\n      secondsSinceEpoch\n    }, moreMeta));\n    return collection;\n  }, []);\n};\n\nexport function posts() {\n  return postFileNames().then(fileNameList => {\n    const postList = createPostList(fileNameList);\n    const sortedList = postList.sort((a, b) => a.secondsSinceEpoch - b.secondsSinceEpoch).reverse();\n    return sortedList;\n  }).catch(error => console.log(\"Error creating postList\", error));\n}","map":{"version":3,"sources":["/home/wajari/dev/blog-next/utils/post-list.js"],"names":["formatSEODate","getSecondsSinceEpoch","config","postFileNames","Promise","resolve","createPostList","fileNameList","reduce","collection","name","default","Component","require","meta","title","tags","layout","publishDate","modifiedDate","seoDescription","hideProgressBar","exclude","moreMeta","cleaned_name","split","formattedPublishDate","formattedModifiedDate","secondsSinceEpoch","push","urlPath","fullUrlPath","canonicalUrl","baseUrl","type","posts","then","postList","sortedList","sort","a","b","reverse","catch","error","console","log"],"mappings":";;;;;;;;;;AAAA,SAASA,aAAT,EAAwBC,oBAAxB,QAAoD,cAApD;AACA,SAASC,MAAT,QAAuB,sBAAvB;;AAEA,MAAMC,aAAa,GAAG,MAAM;AACxB,QAAMA,aAAa,GACf,2KACA,EAFJ;AAGA,SAAOC,OAAO,CAACC,OAAR,CAAgBF,aAAhB,CAAP;AACH,CALD;;AAOA,MAAMG,cAAc,GAAGC,YAAY,IAAI;AACnC,SAAOA,YAAY,CAACC,MAAb,CAAoB,CAACC,UAAD,EAAaC,IAAb,KAAsB;AAC7C;AACA;AACA,UAAM;AAAEC,MAAAA,OAAO,EAAEC;AAAX,QAAyBC,OAAO,CAAE,iBAAgBH,IAAK,EAAvB,CAAtC;;AACA,0BAUIG,OAAO,CAAE,iBAAgBH,IAAK,EAAvB,CAAP,CAAiCI,IAVrC;AAAA,UAAM;AACFC,MAAAA,KADE;AAEFC,MAAAA,IAFE;AAGFC,MAAAA,MAHE;AAIFC,MAAAA,WAJE;AAKFC,MAAAA,YALE;AAMFC,MAAAA,cANE;AAOFC,MAAAA,eAAe,GAAG,KAPhB;AAQFC,MAAAA,OAAO,GAAG,KARR,CASU;;AATV,KAAN;AAAA,UASOC,QATP;;AAYA,QAAID,OAAJ,EAAa,OAAOb,UAAP,CAhBgC,CAkB7C;;AACA,UAAMe,YAAY,GAAGd,IAAI,CAACe,KAAL,CAAW,GAAX,EAAgB,CAAhB,CAArB,CAnB6C,CAqB7C;AACA;AACA;;AACA,UAAMC,oBAAoB,GAAG1B,aAAa,CAACkB,WAAD,CAA1C;AAEA,UAAMS,qBAAqB,GAAG3B,aAAa,CAACmB,YAAD,EAAe,IAAf,CAA3C,CA1B6C,CA4B7C;;AACA,UAAMS,iBAAiB,GAAG3B,oBAAoB,CAACyB,oBAAD,CAA9C,CA7B6C,CA+B7C;;AACAjB,IAAAA,UAAU,CAACoB,IAAX;AACIjB,MAAAA,SADJ;AAEIG,MAAAA,KAFJ;AAGIC,MAAAA,IAHJ;AAIIC,MAAAA,MAJJ;AAKIC,MAAAA,WALJ;AAMIQ,MAAAA,oBANJ;AAOIP,MAAAA,YAPJ;AAQIQ,MAAAA,qBARJ;AASIP,MAAAA,cATJ;AAUIE,MAAAA,OAVJ;AAWIQ,MAAAA,OAAO,EAAG,IAAGN,YAAa,EAX9B;AAYIO,MAAAA,WAAW,EAAG,SAAQP,YAAa,EAZvC;AAaIQ,MAAAA,YAAY,EAAG,GAAE9B,MAAM,CAAC+B,OAAQ,IAAGT,YAAa,EAbpD;AAcIH,MAAAA,eAdJ;AAeIX,MAAAA,IAAI,EAAEc,YAfV;AAgBIU,MAAAA,IAAI,EAAE,MAhBV;AAiBIN,MAAAA;AAjBJ,OAkBOL,QAlBP;AAqBA,WAAOd,UAAP;AACH,GAtDM,EAsDJ,EAtDI,CAAP;AAuDH,CAxDD;;AA0DA,OAAO,SAAS0B,KAAT,GAAiB;AACpB,SAAOhC,aAAa,GACfiC,IADE,CACG7B,YAAY,IAAI;AAClB,UAAM8B,QAAQ,GAAG/B,cAAc,CAACC,YAAD,CAA/B;AACA,UAAM+B,UAAU,GAAGD,QAAQ,CACtBE,IADc,CACT,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACZ,iBAAF,GAAsBa,CAAC,CAACb,iBADzB,EAEdc,OAFc,EAAnB;AAGA,WAAOJ,UAAP;AACH,GAPE,EAQFK,KARE,CAQIC,KAAK,IAAIC,OAAO,CAACC,GAAR,CAAY,yBAAZ,EAAuCF,KAAvC,CARb,CAAP;AASH","sourcesContent":["import { formatSEODate, getSecondsSinceEpoch } from \"./formatters\";\nimport { config } from \"../config/config.yml\";\n\nconst postFileNames = () => {\n    const postFileNames =\n        preval`module.exports = require(\"fs\").readdirSync(\"./pages/blog\")` ||\n        [];\n    return Promise.resolve(postFileNames);\n};\n\nconst createPostList = fileNameList => {\n    return fileNameList.reduce((collection, name) => {\n        // These are properties we want to extract from the file's meta export.\n        // This data is returned is added to the `collection` array below.\n        const { default: Component } = require(`../pages/blog/${name}`);\n        const {\n            title,\n            tags,\n            layout,\n            publishDate,\n            modifiedDate,\n            seoDescription,\n            hideProgressBar = false,\n            exclude = false,\n            ...moreMeta // any extra properties a post may have\n        } = require(`../pages/blog/${name}`).meta;\n\n        if (exclude) return collection;\n\n        // remove the extension from the file name to make a component name string\n        const cleaned_name = name.split(\".\")[0];\n\n        // format dates for SEO, but preserve publishDate as the latter is\n        // displayed on the blog post. Currently not displaying modifiedDate, but\n        // preserving it for possible future use.\n        const formattedPublishDate = formatSEODate(publishDate);\n\n        const formattedModifiedDate = formatSEODate(modifiedDate, true);\n\n        // This is used to sort pages/posts\n        const secondsSinceEpoch = getSecondsSinceEpoch(formattedPublishDate);\n\n        // data that is returned for each page\n        collection.push({\n            Component,\n            title,\n            tags,\n            layout,\n            publishDate,\n            formattedPublishDate,\n            modifiedDate,\n            formattedModifiedDate,\n            seoDescription,\n            exclude,\n            urlPath: `/${cleaned_name}`,\n            fullUrlPath: `/blog/${cleaned_name}`,\n            canonicalUrl: `${config.baseUrl}/${cleaned_name}`,\n            hideProgressBar,\n            name: cleaned_name,\n            type: \"post\",\n            secondsSinceEpoch,\n            ...moreMeta // any extra properties a post may have\n        });\n\n        return collection;\n    }, []);\n};\n\nexport function posts() {\n    return postFileNames()\n        .then(fileNameList => {\n            const postList = createPostList(fileNameList);\n            const sortedList = postList\n                .sort((a, b) => a.secondsSinceEpoch - b.secondsSinceEpoch)\n                .reverse();\n            return sortedList;\n        })\n        .catch(error => console.log(\"Error creating postList\", error));\n}\n"]},"metadata":{},"sourceType":"module"}